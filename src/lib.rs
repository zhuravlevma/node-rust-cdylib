use neon::prelude::*;
use quad_rand as qrand;

fn hello(mut cx: FunctionContext) -> JsResult<JsString> {
    Ok(cx.string("hello node"))
}

#[neon::main]
fn main(mut cx: ModuleContext) -> NeonResult<()> {
    cx.export_function("hello", hello)?;
    cx.export_function("fibonacci", fibonacci_api)?;
    cx.export_function("matrix", matrix_api)?;
    Ok(())
}


fn fibonacci(n: i32) -> i32 {
    return match n {
        n if n < 1 => 0,
        n if n <= 2 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2)
    }
}

pub fn matrix() -> i64 {
    let matrix: [[i64; 13]; 39] =
        [
            [4, 6, 7, 8, 32, 5345, 66, 12, 545, 67, 654, 232, 654],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [5, 32, 47, 568, 75432, 5345, 66, 3212, 4545, 5467, 43654, 2232, 6554],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 2452323, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 4, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5, 754232, 53345, 66, 33212, 6, 55467, 43654, 22632, 7],
            [53, 332, 447, 5638, 754232, 53345, 66, 7, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 6, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 5],
            [53, 332, 7, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 3, 447, 5638, 754232, 53345, 66, 33212, 7, 55467, 5, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [4, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 24, 43654, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [53, 3, 447, 5638, 43, 53345, 66, 3, 7, 55467, 5, 22632, 54],
            [53, 332, 447, 5638, 754232, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
            [4, 332, 447, 5638, 43, 53345, 66, 33212, 4545, 55467, 43654, 22632, 54],
        ];
    let mut result: i64 = 0;

    for i in 0..matrix.len() {
        for j in 0..matrix[i].len() {
            for m in 0..matrix.len() {
                for n in 0..matrix[m].len() {
                    if m == i && n == j {
                        continue
                    }
                    let x = qrand::rand() as i64;

                    let num: i64 = matrix[m][n];
                    result += num.pow(3) + x;
                }
            }
        }
    }

    result
}

fn matrix_api(mut cx: FunctionContext) -> JsResult<JsNumber> {
    let res = matrix() as i32;
    Ok(cx.number(res))
}

fn fibonacci_api(mut cx: FunctionContext) -> JsResult<JsNumber> {
    let handle = cx.argument::<JsNumber>(0).unwrap();
    let res = fibonacci(handle.value(&mut cx) as i32);
    Ok(cx.number(res))
}